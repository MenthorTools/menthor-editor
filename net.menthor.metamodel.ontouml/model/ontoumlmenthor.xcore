@Ecore(
	nsPrefix="ontouml-menthor", //Used for XMI serialization
	nsURI="http://menthor.net/" 
)

@GenModel( 
	testsDirectory="/net.menthor.metamodel.ontouml.tests/src-gen",
	editDirectory="/net.menthor.metamodel.ontouml.edit/src-gen",
	editorDirectory="/net.menthor.metamodel.ontouml.editor/src-gen",
	fileExtensions="mouml"
)
 
package net.menthor.metamodel.ontouml

// TODO: JP: Name Spaces like in UML (with package imports)
// TODO: JP: Support for Comments

/* TODO: JP: Create a separate meta-model for "occurrences" of the elements in views
 * (similar to occurrences and definitions in ARIS) keep this meta-model for definitions
 * and create a meta-model for occurrences. This will enable a strict separation between model and views */
 
@Ecore(validationDelegates="http://www.eclipse.org/emf/2002/Ecore/OCL/Pivot")

abstract class Element { }

abstract class NamedElement extends Element { String name }

abstract class Container extends NamedElement { contains unordered unique ContainedElement[*] elements opposite holder}

abstract class ContainedElement extends Element 
{ 
	container Container[1] holder opposite elements
	contains Comment[*] comments opposite owner
}

//=========================================

class Model extends Container { }

class Package extends Container, ContainedElement { }

//=========================================

class Comment extends Element 
{ 
	String content
	container ContainedElement[1] owner opposite comments
}

//=========================================

enum Universal 
{	
	Kind, Collective, Quantity, Relator, Mode, Quality,  
	Role, Phase, SubKind, Category, Mixin, RoleMixin, PhaseMixin, Event, Hou, DataType, Enumeration
}

class Class extends NamedElement, ContainedElement
{	
	Universal[0..1] stereotype
	
	boolean isAbstract	
	boolean isDerived
	
	derived boolean isExtensional // ends read only do lado da target
	
	String[*] enumerationLiterals //<<Enumeration>>
	
	refers unordered unique Class[*] instanceOf //<<hou>>
	
	refers unordered unique ClassBinaryRelationship[*] istruthMakerOf opposite truthMaker ////<<relator>>
	
	refers unordered unique Attribute[*] attributes opposite owner
	
	refers unordered unique GeneralizationSet[*] isSpecializedVia opposite specializedClass
	refers unordered unique GeneralizationSet[*] specializesVia opposite specializingClasses	
		
	//==============================================
	//Operations
	//==============================================
	
	op boolean isRigid()
	{
		stereotype==Universal.KIND || stereotype==Universal.COLLECTIVE || stereotype==Universal.QUANTITY || 
		stereotype==Universal.RELATOR || stereotype==Universal.MODE || 
		stereotype==Universal.QUALITY || 
		stereotype==Universal.SUB_KIND ||
		stereotype==Universal.CATEGORY
	} 
	op boolean isNonRigid()
	{
		stereotype==Universal.ROLE || stereotype==Universal.PHASE || stereotype==Universal.ROLE_MIXIN || stereotype==Universal.MIXIN
	} 
	op boolean isAntiRigid()
	{
		stereotype==Universal.ROLE || stereotype==Universal.PHASE || stereotype==Universal.ROLE_MIXIN
	} 
//	op void identidyProvider(){}
	
//	op void isFunctionalComplex(){}	
//	op void isCollection(){}
//	op void isAmountOfMatter(){}
//	op void isIntrinsic(){}
//	op void isTruthMaker(){}	
	
//	op void isKind(){}
//	op void isSubKind(){}
//	op void isCollective(){}
//	op void isQuantity(){}
//	op void isRelator(){}
//	op void isMode(){}
//	...

	//op parent() {}
	
//	op void setIsExtensional(){}
}

//=========================================

class PrimitiveType extends ContainedElement
{
	Primitive[1] stereotype 
}

enum Primitive
{
	/** JP: This is a direct way to implement built-in types, differently from UML in which 
	 *  this should be a library of built-ins at model level */
	Boolean, String, Real, Integer, UnlimitedNatural
}

//=========================================

class GeneralizationSet extends NamedElement, ContainedElement
{
	boolean isCovering
	
	/* JP: Default should be true, but isDijoint has been removed. Use different GeneralizationSets if necessary to represent disjointness. */
	// boolean isDisjoint 
		
	/* JP: We diverge from UML, which refers to Generalizations from a GeneralizationSet */
	refers Class[1] specializedClass opposite isSpecializedVia
	refers unordered unique Class[1..*] specializingClasses opposite specializesVia
		
	refers Class[0..1] hou 
}

//=========================================

abstract class Property extends NamedElement 
{		
	boolean isOrdered
	boolean isDerived	
	int[1] lowerBound
	int[1] upperBound	
	boolean isDependee	
}
  
class Attribute extends Property
{
	refers Class[1] owner opposite attributes
	
	refers PrimitiveType[1] primitiveType  	
}

//=========================================

class EndPoint extends Property
{	
	refers ClassBinaryRelationship[1] owner opposite endPoints
	
	refers Class[1] endType
	
	refers unordered unique EndPoint[*] subsets opposite isSubsettedBy
	refers unordered unique EndPoint[*] redefines opposite isRedefinedBy
	
	refers unordered unique EndPoint[*] isSubsettedBy opposite subsets
	refers unordered unique EndPoint[*] isRedefinedBy opposite redefines
}

//=========================================

class ClassBinaryRelationship extends NamedElement, ContainedElement
{	
	/* JP: I assume there is no reason to distinguish ordered and non-ordered, as all should be non-ordered. 
	 * We assume ordered end points... 
	 * http://link.springer.com/chapter/10.1007%2F978-3-642-41924-9_40 */
	 
	/* JP: I assume all are unique as well (mapping to sets and not bags). */
	/* JP: If there are two relators relating the same entities, there should not be two material relations 
	 * between the same entities... the tuples are identical e.g., you should not say that there are two "student at" 
	 * relations between "Student" and "University" even if there are two "Enrollments".  */
	
	Relation[0..1] stereotype
	
	refers EndPoint[2] endPoints opposite owner
				
	boolean partIsShareable
	
	AllenRelation[0..1] allensRelation //<<Temporal>>
	
	refers Class[0..1] truthMaker opposite istruthMakerOf
	
	//transformar em operaçoes....
	derived boolean isDerived get { sourceEnd().isDerived || targetEnd().isDerived }		 
	derived boolean partIsEssential	get { targetEnd().isDependee && sourceEnd().endType.isRigid() && isMeronymic() }  
	derived boolean partIsInseparable get { sourceEnd().isDependee && targetEnd().endType.isRigid() && isMeronymic() }
	derived boolean partIsImmutable get { sourceEnd().isDependee && targetEnd().endType.isAntiRigid() && isMeronymic()} 
	derived boolean wholeIsImmutable get { targetEnd().isDependee && sourceEnd().endType.isAntiRigid() && isMeronymic()}		
	derived boolean partIsMandatory get { targetEnd().lowerBound>=1 && isMeronymic()}
	derived boolean wholeIsMandatory get { sourceEnd().lowerBound>=1 && isMeronymic()}

	//==============================================
	//Operations
	//==============================================
	
	op EndPoint sourceEnd()
	{
		return endPoints.get(0)
	}	
	op EndPoint targetEnd()
	{
		return endPoints.get(1)
	}
	op boolean isMeronymic()
	{
		stereotype==Relation.COMPONENT_OF || stereotype==Relation.MEMBER_OF || stereotype==Relation.SUB_QUANTITY_OF || stereotype==Relation.SUB_COLLECTION_OF
	} 
}	

enum Relation 
{
	//UFO-A
	ComponentOf
	MemberOf
	SubCollectionOf
	SubQuantityOf
	Constitution
	Characterization
	Mediation
	Material
	Formal
	Structuration
		
	//UFO-B
	Participation
	SubEventOf
	Causation //Causality, CausedBy
	Temporal	
}

enum AllenRelation
{
	Starts
	Precedes
	Equals
	Meets
	Finishes
	Overlaps
	During
}

//=========================================

class Dimension extends NamedElement, ContainedElement 
{
	int[1] lowerBound
	int[1] upperBound
	//missing
	//operations
}

class Domain extends NamedElement, ContainedElement 
{
	//missing
	//operations
}
