@Ecore(
	nsPrefix="ontouml-menthor", //Used for XMI serialization
	nsURI="http://menthor.net/" 
)

@GenModel( 
	testsDirectory="/net.menthor.metamodel.ontouml.tests/src-gen",
	editDirectory="/net.menthor.metamodel.ontouml.edit/src-gen",
	editorDirectory="/net.menthor.metamodel.ontouml.editor/src-gen",
	fileExtensions="mouml"
)
 
package net.menthor.metamodel.ontouml

// TODO: JP: Name Spaces like in UML (with package imports)

/* TODO: JP: Create a separate meta-model for "occurrences" of the elements in views
 * (similar to occurrences and definitions in ARIS) keep this meta-model for definitions
 * and create a meta-model for occurrences. This will enable a strict separation between model and views */

//TODO: Tiago: Regra para verificar especializacao multipla (nao pode especializar dois tipos disjuntos)
//TODO: Tiago: Sub-setting and Redefinition Constraints.
 
@Ecore(validationDelegates="http://www.eclipse.org/emf/2002/Ecore/OCL/Pivot")

/** =========================================
 *  - elements & named elements
 *  ======================================== */
 
abstract class Element { }

abstract class NamedElement extends Element { String name }

/** =========================================
 *  - container & contained elements
 * 
 *  A container is a named element that contains a set of elements (i.e. model, packages).
 * 
 *  A contained element is an element that has a holder (a container) and possibly a set of comments.
 *  A contained element can be: a package, a classifier [class, relationship, structure, region, domain and dimension], or a generalization set.  *    
 *  ======================================== */
 
abstract class Container extends NamedElement 
{ 
	contains unordered unique ContainedElement[*] elements opposite holder
	
	//==============================================
	//operations
	//==============================================
	
	/* Returns the packages at this container. It only returns direct packages. */  
	op Package[] packages()
	{
		var Package[] result
		for(ContainedElement e: elements){
			if(e instanceof Package) { result.add(e); }			
		}
		return result.toEList;
	}
	
	/** Returns all packages at this container recursively. It returns both direct and indirect packages. */
	op void allPackages(Container c, Package[] result)
	{		
		for(ContainedElement e: elements){
			if(e instanceof Package) { 
				result.add(e);				
				allPackages(e,result);
			}				
		}		
	}	
	op Package[] allPackages()
	{
		var Package[] result
		allPackages(this, result.toEList)
		return result.toEList;
	} 
	
	/* Returns the relationships at this container */
	op Relationship[] relationships() 
	{	
		var Relationship[] result
		for(ContainedElement e: elements){
			if(e instanceof Relationship) { result.add(e) }
		}
		return result.toEList;
	}
	
	/** Returns all relationships at this container recursively. It returns both direct and indirect relationships. */
	op void allRelationships(Container c, Relationship[] result)
	{		
		for(ContainedElement e: elements){
			if(e instanceof Relationship) { result.add(e); }
			if(e instanceof Package){
				allRelationships(e,result);								
			}
		}
	}	
	op Relationship[] allRelationships()
	{
		var Relationship[] result
		allRelationships(this, result.toEList)
		return result.toEList;
	} 
	
	/* Returns the generalization sets at this container */
	op GeneralizationSet[] generalizationSets()
	{
		var GeneralizationSet[] result
		for(ContainedElement e: elements){
			if(e instanceof GeneralizationSet) { result.add(e) }
		}
		return result.toEList;		
	} 
	 
	/** Returns all generalization sets at this container recursively. It returns both direct and indirect generalization sets. */
	op void allGeneralizationSets(Container c, GeneralizationSet[] result)
	{		
		for(ContainedElement e: elements){
			if(e instanceof GeneralizationSet) { result.add(e); }
			if(e instanceof Package){
				allGeneralizationSets(e,result);								
			}
		}
	}	
	op GeneralizationSet[] allGeneralizationSets()
	{
		var GeneralizationSet[] result
		allGeneralizationSets(this, result.toEList)
		return result.toEList;
	} 
	
	/* Returns the classes at this container */
	op Class[] classes()
	{
		var Class[] result
		for(ContainedElement e: elements){
			if(e instanceof Class) { result.add(e) }
		}
		return result.toEList;		
	}
	
	/** Returns all classes at this container recursively. It returns both direct and indirect classes. */
	op void allClasses(Container c, Class[] result)
	{		
		for(ContainedElement e: elements){
			if(e instanceof Class) { result.add(e); }
			if(e instanceof Package){
				allClasses(e,result);								
			}
		}
	}	
	op Class[] allClasses()
	{
		var Class[] result
		allClasses(this, result.toEList)
		return result.toEList;
	}	
}

abstract class ContainedElement extends Element 
{ 
	container Container[1] holder opposite elements
	
	contains Comment[*] comments opposite owner	
}

/** =========================================
 *  - model & package
 *  ======================================== */

class Model extends Container { }

class Package extends Container, ContainedElement { }

/** =========================================
 *  - comment
 * 
 *  A comment has a string content and an owner.
 *  ======================================== */

class Comment extends Element 
{ 
	String content
	container ContainedElement[1] owner opposite comments
}

/** =========================================
 *  - classifier (i.e. Class or Relationship)
 * 
 *  A classifier is a contained element defined to be a Class or a Relationship.
 *  ======================================== */
 
abstract class Classifier extends ContainedElement 
{
	refers unordered unique GeneralizationSet[*] isSpecializedVia opposite specializedClassifier
	refers unordered unique GeneralizationSet[*] specializesVia opposite specializingClassifier
	
	//==============================================
	//operations
	//==============================================
	
	/* Direct children */
	op Classifier[] children() 
	{		
		var Class[] list
		for(GeneralizationSet gs: isSpecializedVia) { 
			list.addAll(gs.specializingClassifier);		
		}
		return list.toEList;
	}

	/** Direct parents */
	op Classifier[] parents() 
	{
		var Classifier[] list
		for(GeneralizationSet gs: specializesVia) { 
			list.add(gs.specializedClassifier);		
		}
		return list.toEList;
	}
	
	/** All (direct and indirect) parents */
	op void allParents(Classifier c, Classifier[] result) 
	{		
		for(GeneralizationSet gs: specializesVia) { 
			result.add(gs.specializedClassifier);
			allParents(gs.specializedClassifier,result);					
		}		
	}	
	/** All (direct and indirect) parents */
	op Classifier[] allParents()
	{
		var Classifier[] list
		allParents(this, list.toEList)
		return list.toEList;
	}
	
	/* All (direct and indirect) children */
	op void allChildren(Classifier c, Classifier[] result) 
	{		
		for(GeneralizationSet gs: isSpecializedVia) { 
			result.addAll(gs.specializingClassifier);
			for(Classifier children: gs.specializingClassifier) {				
				allChildren(children, result);			
			}					
		}		
	} 
	/* All (direct and indirect) children */
	op Classifier[] allChildren()
	{
		var Classifier[] list
		allChildren(this, list.toEList)
		return list.toEList;
	}
}

/** =========================================
 *  - class stereotypes
 * 
 *  UFO's universals are defined here as simple enumerations instead of types hierarchies.
 *  Applications need to allow us change an element type (e.g. let's say, a kind into a role)
 *  We should not need to delete the class, create a new one, and then change all former references in the model 
 *  that previously pointed to that class, to point to the new class created. 
 *  ======================================== */

enum Universal 
{	
	//UFO-A
	Kind, Collective, Quantity, 
	Relator, Mode, Quality,  
	Role, Phase, SubKind, 
	Category, Mixin, RoleMixin, PhaseMixin,
	DataType, Enumeration,
	
	//UFO-B 
	Event, 
	
	//High Order Universal
	Hou 
}

enum Quality 
{
	//UFO-A
	Nominal, Perceivable, NonPerceivable	
}

/** =========================================
 *  - class
 * 
 *  A class is named classifier that may have a stereotype. 
 *  In the case where the stereotype is an enumeration, the class must have 2 or more enumeration literals (constraint C1).
 *  In the case where the stereotype is a quality, the class must define a quality type (constraint C4).
 *  A class may also be abstract or derived, and contain a set of attributes.
 *  Data-Types and Enumeration cannot be derived (Constraint C6).
 *  Enumerations may be a ground for a quality reference structure (Constraint C17).
 *  In the case where the stereotype is not a hou, data-type or enumeration, the class may be an instance of one or more high order classes (constraint C2, C3).
 *  In the case where the class is a truth maker (relator's descendant or relator), that class may be a truth maker for one or more material relationships (constraint C5).
 *  A class may be in a set of generalization sets as super-class or sub-class.
 *  ======================================== */
 
class Class extends NamedElement, Classifier
{	
	Universal[?] stereotype	
	
	boolean isAbstract	
	boolean isDerived	 
	
	contains unordered unique Attribute[*] attributes opposite owner
	
	//quality
	Quality[?] qualityType 
	
	//enumeration
	contains Literal[*] literals opposite owner		
	refers Structure[?] groundingStructure opposite groundedEnumeration
	
	//high order
	refers unordered unique Class[*] instanceOf
	
	//truth makers (e.g. relators) 
	refers unordered unique Relationship[*] istruthMakerOf opposite derivedFromTruthMaker 
	
	boolean isExtensional
		
	//==============================================
	//operations
	//==============================================
	
	op boolean isKind(){stereotype==Universal.KIND}
	op boolean isSubKind(){stereotype==Universal.SUB_KIND}
	op boolean isCollective(){stereotype==Universal.COLLECTIVE}
	op boolean isQuantity(){stereotype==Universal.QUANTITY}
	op boolean isRelator(){stereotype==Universal.RELATOR}
	op boolean isMode(){stereotype==Universal.MODE}
	op boolean isQuality(){stereotype==Universal.QUALITY}
	op boolean isRole(){stereotype==Universal.ROLE}
	op boolean isRoleMixin(){stereotype==Universal.ROLE_MIXIN}
	op boolean isPhaseMixin(){stereotype==Universal.PHASE_MIXIN}
	op boolean isPhase(){stereotype==Universal.PHASE}
	op boolean isCategory(){stereotype==Universal.CATEGORY}
	op boolean isMixin(){stereotype==Universal.MIXIN}
	op boolean isEvent(){stereotype==Universal.EVENT}
	op boolean isHighOrder(){stereotype==Universal.HOU}
	op boolean isDataType(){stereotype==Universal.DATA_TYPE}
	op boolean isEnumeration(){stereotype==Universal.ENUMERATION}
	op boolean isRigid() { isKind() || isCollective() || isQuantity() ||isRelator() || isMode() || isQuality() ||isSubKind() || isCategory() } 
	op boolean isNonRigid() { isRole()|| isPhase() || isRoleMixin() || isMixin() } 
	op boolean isAntiRigid() { isRole() || isPhase() || isRoleMixin() }
	op boolean isSemiRigid() { isRoleMixin() || isPhaseMixin() || isMixin() }
	
	/** Checks if this class is a direct identity provider 
	 *  i.e. it does not inherit his identity from other classes. */
	op boolean isIdentityProvider() 
	{ 
		return isKind() || isQuantity() || isCollective() || isRelator() || isMode()
	}
	
	/** Checks if this class is a relator (or descendant of a relator) 
	 *  and is related to one or more material relationships */
	op boolean isTruthMaker()
	{
		if (isRelator() && istruthMakerOf.size()>0) { return true; }
		for(Classifier c: allParents()) {
			if(c instanceof Class){								
				if (c.isRelator() && istruthMakerOf.size()>0) { return true; }
			}
		}
		return false;		
	}	
	
	/** Checks if this class is a Mixin, Category, RoleMixin or PhaseMixin */
	op boolean isMixinClass()
	{
		if(isMixin() || isRoleMixin() || isPhaseMixin() || isCategory()) { return true; }		
		else { return false; }		
	}
	
	/** Returns the identity providers amongst all parents of a class (more than one may be found) */
	op Class[] identityProvidersAtAllParents()
	{
		var Class[] result
		for(Classifier p: allParents()) {
			if(p instanceof Class){		
				if(p.isIdentityProvider()) result.add(p);
			}			
		}
		return result.toEList;
	}

	/** Returns the identity providers amongst all children of a class (more than one may be found) */
	op Class[] identityProvidersAtAllChildren()
	{
		var Class[] result
		for(Classifier p: allChildren()) {
			if(p instanceof Class){		
				if(p.isIdentityProvider()) result.add(p);
				if(p.isAntiRigid() || p.isSubKind()) result.addAll(p.identityProvidersAtAllParents());
			}			
		}
		return result.toEList;
	}	
	
	/** Returns the identity providers of a class (more than one may be found) */
	op Class[] identityProviders()
	{
		var Class[] result
		if (isIdentityProvider()) {
			result.add(this);
		}				
		if (isAntiRigid() || isSubKind()) { 
			result.addAll(identityProvidersAtAllParents());
		}	
		if (isMixinClass())
		{
			result.addAll(identityProvidersAtAllChildren());	
			for(Classifier p: allParents()) {
				if(p instanceof Class){		
					result.addAll(p.identityProvidersAtAllChildren());
				}
			}	
		}
		return result.toEList;			
	}	
	
	/** 
	 * Checks if this class is an amount of matter i.e.
	 * 1) if it is a quantity element, or, 
	 * 2) if it is a sub-kind or anti-rigid with exactly one identity provider of the type Quantity, or,
	 * 3) if it is a mixin class in which all their children are quantities.
	 */
	op boolean isAmountOfMatter()
	{
		if(isQuantity()) return true;		
		if(isAntiRigid() || isSubKind()) 
		{ 
			var Class[] providers
			providers.addAll(identityProviders());			
			for(Class c: providers) if (c.isQuantity()) return true;
		}		
		if(isMixinClass())
		{
			if(children().size()==0) return false;			
			for (Classifier child : children()) 
			{
				if(child instanceof Class) if(!child.isQuantity()) return false;
			}
			return true;
		}		
		return false;
	}
	
	/** 
	 * Checks if this element is a functional complex i.e.
	 * 1) If it is a kind, or 
	 * 2) if it is a sub-kind or anti-rigid with exactly one identity provider of the type kind, or,
	 * 3) if it is a mixin class in which all their children are functional complexes.  
	 */
	op boolean isFunctionalComplex()
	{
		if(isKind()) return true;		
		if(isAntiRigid() || isSubKind()) 
		{ 
			var Class[] providers
			providers.addAll(identityProviders());			
			for(Class c: providers) if (c.isKind()) return true;
		}		
		if(isMixinClass())
		{			
			if(children().size()==0) return false;			
			for (Classifier child : children()) 
			{
				if(child instanceof Class) if(!child.isKind()) return false;
			}
			return true;
		}		
		return false;
	}	
	
	/** 
	 * Checks if a particular element is a collective i.e.
	 * 1) if it is a collective element, or, 
	 * 2) if it is a sub-kind or anti-rigid with exactly one identity provider of the type Collective, or,
	 * 3) if it is a mixin class in which all their children are collectives.
	 */
	op boolean isCollection()
	{ 
		if(isCollective()) return true;		
		if(isAntiRigid() || isSubKind()) 
		{ 
			var Class[] providers
			providers.addAll(identityProviders());			
			for(Class c: providers) if (c.isCollective()) return true;
		}			
		if(isMixinClass())
		{			
			if(children().size()==0) return false;			
			for (Classifier child : children()) 
			{
				if(child instanceof Class) if(!child.isCollective()) return false;
			}
			return true;
		}		
		return false;
	}	 
	
	/** Returns direct siblings i.e. classes which specialize the same super-type as this class */
	op void siblings() {}

	op void overlapSiblings(){}
	
	op void disjointSiblings(){}

	/** Checks if this class is disjoint from another */
	op void isDisjointOf(Class c){}
	
	/** Returns all (direct) end-points "connected" to this class. 
	 *  In other words, it returns all opposite ends of the relationships connected to this class. */		
	op void ends(){}
	  
	/** Returns all classes directly connected to this class through a relationship. */
	op void relatedClasses(){}
	
	/**Returns all classes directly and indirectly connected to this class through a relationship. */
	op void allRelatedClasses(){}
	
	/** Returns all (direct and indirect) end-points "connected" to this class. 
	 *  In other words, it returns all opposite ends of the relationships connected to this class. */
	op void allEnds(){}
	
	op void isIntrinsic(){}
}

/** =========================================
 *  - generalization set
 *   
 *  A former UML generalization is a generalization set with only one specializing class.
 *  A generalization set can be complete. Generalization sets are by default disjoint.
 *  Generalization sets cannot define cycles (Constraint C8, C9, C10, C11)
 *  Further, a generalization set may refer to a high order class (Constraint C7).
 *  ======================================== */

class GeneralizationSet extends NamedElement, ContainedElement
{
	boolean isCovering
	
	/* JP: Default should be true, but isDijoint has been removed. Use different GeneralizationSets if necessary to represent disjointness. */
	// boolean isDisjoint 
		
	/* JP: We diverge from UML, which refers to Generalizations from a GeneralizationSet */
	refers Classifier[1] specializedClassifier opposite isSpecializedVia 
	refers unordered unique Classifier[1..*] specializingClassifier opposite specializesVia 
		
	refers Class[?] hou 
}

/** =========================================
 *  - property
 * 
 *  A property is a named element which can be ordered, derived and have a dependency to a type (UML readOnly or frozen feature).
 *  A property defines a lower and upper bound defining how many elements are allowable at this property.
 *  ======================================== */

abstract class Property extends NamedElement 
{		
	boolean isOrdered
	boolean isDerived	
	int[1] lowerBound
	int[1] upperBound	
	boolean isDependency	
}

/** =========================================
 *  - attribute & primitive types
 * 
 *  An attribute is a property that has an owner class and a primitive type.
 * 
 *  A primitive type is a contained element which does not have a name.
 *  A primitive type have a primitive stereotype such as Integer, String, Real, Boolean, UnlimitedNatural and Date
 *  ======================================== */

class Attribute extends Property
{
	container Class[1] owner opposite attributes
	
	Primitive[1] primitive 	
}
  
enum Primitive
{
	/** JP: This is a direct way to implement built-in types, differently from UML in which 
	 *  this should be a library of built-ins at model level */
	Boolean, String, Real, Integer, Decimal, UnlimitedNatural, Date
}

/** =========================================
 *  - enumeration literals
 *  ======================================== */

class Literal extends Property
{
	container Class[1] owner opposite literals
	
	refers Region[?] groundingRegion opposite groundedLiteral
	
	String value
} 

/** =========================================
 *  - end-point
 * 
 *  An end-point is a property that has relationship owner and a end classifier (class or relationship, because of derivation relationships).
 *  An end-point may also have subsets or redefines a set of other end-points, and also be subsetted and redefined by others.
 *  ======================================== */
 
class EndPoint extends Property
{	
	container Relationship[1] owner opposite endPoints
	
	refers Classifier[1] endType
	
	refers unordered unique EndPoint[*] subsets opposite isSubsettedBy
	refers unordered unique EndPoint[*] redefines opposite isRedefinedBy
	
	refers unordered unique EndPoint[*] isSubsettedBy opposite subsets
	refers unordered unique EndPoint[*] isRedefinedBy opposite redefines
}

/** =========================================
 *  - relationship stereotypes
 *  
 *  UFO's universals are defined here as simple enumerations instead of a hierarchy of types.
 *  Applications need to allow us change a relationship type (e.g. let's say, a mediation into a characterization)
 *  We should not need to delete the relationship, create a new one, and then change all former references in the model 
 *  that previously pointed to that relationship, to point to the new element created. 
 *  ======================================== */
 
enum Relation 
{
	//UFO-A
	ComponentOf
	MemberOf
	SubCollectionOf
	SubQuantityOf
	Constitution
	Characterization
	Mediation
	Material
	Formal
	Structuration
	Derivation
	
	//UFO-B
	Participation
	SubEventOf
	Causation //Causality, CausedBy
	Temporal	
}

enum Temporal
{
	Starts
	Precedes
	Equals
	Meets
	Finishes
	Overlaps
	During
}

/** =========================================
 *  - relationship
 * 
 *  A relationship is a classifier (not named) which may have a stereotype.
 *  In the case where the stereotype is temporal (allen's relation), the relationship must define a temporal type (constraint C12).
 *  A relationship has also a set of end-points. 
 *  A relationship can be derived from a truth maker only iff it is a material relationship (constraint C13).
 * 
 *  A derivation relationship:
 *  (i) must be binary (Constraint 14)
 *  (ii) must have as its source a material relationship (Constraint 15)
 *  (iii) must have as its target a truth maker class e.g. a relator (Constraint 16)
 * 
 *  ======================================== */
 
class Relationship extends NamedElement, Classifier
{	
	/* JP: I assume there is no reason to distinguish ordered and non-ordered, as all should be non-ordered.*/
	 
	 /* John & Tiago: We for now assume ordered end-points. 
	 * http://link.springer.com/chapter/10.1007%2F978-3-642-41924-9_40 */
	 
	/* JP: I assume all are unique as well (mapping to sets and not bags). */
	/* JP: If there are two relators relating the same entities, there should not be two material relations 
	 * between the same entities... the tuples are identical e.g., you should not say that there are two "student at" 
	 * relations between "Student" and "University" even if there are two "Enrollments".  */
	
	Relation[?] stereotype
	
	Temporal[?] allenRelation 
	  
	contains EndPoint[*] endPoints opposite owner	
	
	refers Class[?] derivedFromTruthMaker opposite istruthMakerOf
		   
	//==============================================
	//operations
	//==============================================
	
	op void isShareable() { /*TODO*/ }
	
	op boolean isComponentOf(){stereotype==Relation.COMPONENT_OF}
	op boolean isMemberOf(){stereotype==Relation.MEMBER_OF}
	op boolean isSubCollectionOf(){stereotype==Relation.SUB_COLLECTION_OF}
	op boolean isSubQuantityOf(){stereotype==Relation.SUB_QUANTITY_OF}
	op boolean isConstitution(){stereotype==Relation.CONSTITUTION}	
	op boolean isCharacterization(){stereotype==Relation.CHARACTERIZATION}
	op boolean isMediation(){stereotype==Relation.MEDIATION}
	op boolean isMaterial(){stereotype==Relation.MATERIAL}
	op boolean isFormal(){stereotype==Relation.FORMAL}
	op boolean isStructuration(){stereotype==Relation.STRUCTURATION}
	op boolean isParticipation(){stereotype==Relation.PARTICIPATION}
	op boolean isSubEventOf(){stereotype==Relation.SUB_EVENT_OF}
	op boolean isCausation(){stereotype==Relation.CAUSATION}
	op boolean isTemporal(){stereotype==Relation.TEMPORAL}
	op boolean isDerivation(){stereotype==Relation.DERIVATION}
	
	op boolean isStarts(){allenRelation==Temporal.STARTS && isTemporal()}
	op boolean isPrecedes(){allenRelation==Temporal.PRECEDES && isTemporal()}
	op boolean isEquals(){allenRelation==Temporal.EQUALS && isTemporal()}
	op boolean isMeets(){allenRelation==Temporal.MEETS && isTemporal()}
	op boolean isFinishes(){allenRelation==Temporal.FINISHES && isTemporal()}
	op boolean isOverlaps(){allenRelation==Temporal.OVERLAPS && isTemporal()}
	op boolean isDuring(){allenRelation==Temporal.DURING && isTemporal()}		
	op boolean isMeronymic() { isComponentOf() || isMemberOf() || isSubQuantityOf() || isSubCollectionOf() }	
	
	op boolean isBinary() { return endPoints.size()==2 }
	op boolean isTernary() { return endPoints.size()==3 }
	
	op EndPoint sourceEnd() 
	{ 
		if(endPoints.size()>0){ return endPoints.get(0) } 
		return null;
	} 
	
	op EndPoint targetEnd() 
	{ 
		if(endPoints.size()>1){ return endPoints.get(1) } 
		return null;
	}
	
	op Classifier source() 
	{ 
		if(sourceEnd()!=null){ return sourceEnd().endType } 
		return null;
	}
	
	op Classifier target()  
	{ 
		if(targetEnd()!=null){ return targetEnd().endType }		
		return null;
	}
		
	op Class sourceClass() 
	{ 
		if(source()!=null) return source() as Class		
		return null; 
	}
		
	op Class targetClass()  
	{ 
		if(target()!=null) return target() as Class		
		return null;  
	}	
	
	op Relationship sourceRelationship() 
	{ 
		if(source()!=null) return source() as Relationship		
		return null; 
	}
		
	op Relationship targetRelationship()  
	{ 
		if(target()!=null) return target() as Relationship		
		return null;  
	}	
	
	op boolean isDerived() 
	{ 
		for(EndPoint ep: endPoints){ if (ep.isDerived) return true; }
		return false;
	}	
	
	op boolean isPartEssential() { targetEnd().isDependency && sourceClass().isRigid() && isMeronymic() }  
	op boolean isPartInseparable() { sourceEnd().isDependency && targetClass().isRigid() && isMeronymic() }
	op boolean isPartImmutable() { sourceEnd().isDependency && targetClass().isAntiRigid() && isMeronymic()} 
	op boolean isWholeImmutable() { targetEnd().isDependency && sourceClass().isAntiRigid() && isMeronymic()}
	op boolean isPartMandatory() { targetEnd().lowerBound>=1 && isMeronymic()}
	op boolean isWholeMandatory() { sourceEnd().lowerBound>=1 && isMeronymic()}	 
	
	op Relationship material() { }
	
	op Class relator() { }
}
 
/** =========================================
 *  - scale
 *  ======================================== */
 
enum Scale
{
	Interval, Rational, Ordinal, Nominal
}
  
/** =========================================
 *  - structure
 * 
 *  A Structure may have several Regions.
 *  A Structure if grounded, must be grounded in a Enumeration (Constraint C18).
 *  ======================================== */
 
class Structure extends NamedElement, Classifier 
{	 
	refers Region[*] regions opposite ownerStructure
	
	refers Class[?] groundedEnumeration opposite groundingStructure
}
  
/** =========================================
 *  - region
 * 
 *  A Region can be owned by a Structure and be grounded in an Enumeration Literal
 *  A "Composed" Region must have more than one Region.
 *  A "Basic" Region is defined by a Integer or a Decimal measure type.
 *  A "Nominal" Region is defined by a String measure type.
 *  ======================================== */
 
class Region extends NamedElement, Classifier 
{
	refers Structure[?] ownerStructure opposite regions	
	
	refers Literal[?] groundedLiteral opposite groundingRegion
	
	refers Region[*] composedBy //not sure if we should have a "Composed Region" class
	
	Primitive[?] basicType //not sure if we should have a "Basic Region" class 
	
	//==============================================
	//operations
	//============================================== 
	  
	op boolean isBasic() { basicType!=null && composedBy.size()==0 && (basicType==Primitive.INTEGER || basicType==Primitive.DECIMAL) }
	op boolean isComposed() { basicType==null && composedBy.size()>0 }
	op boolean isNominal() { basicType!=null && (basicType==Primitive.STRING) }
}

/** =========================================
 * - domain
 * 
 *  A Domain should always be associated to an instance of measurable quality universal by a structuration relation.
 *  A Domain must have two or more owned dimensions. 
 *  All owned dimensions must be instances of measurement dimensions (not nominal dimensions).
 *  ======================================== */
 
class Domain extends Structure
{
	refers Dimension[*] dimensions opposite ownerDomain
}

/** =========================================
 *  - dimension
 * 
 *  A Dimension might be part of a Domain or connected to a Structuration.
 *  A Dimension might define basic Regions as lower and upper bound (Constraint C19 and C20)
 *  ======================================== */

class Dimension extends Structure 
{ 
	refers Domain[?] ownerDomain opposite dimensions

	refers Region[?] lowerBound 
	refers Region[?] upperBound 
	
	String unitOfMeasure
	
	Scale[?] scale 
	Primitive[?] measure
	
	//==============================================
	//operations
	//============================================== 
	op boolean isNominal() { scale!=null && scale==Scale.NOMINAL }
	op boolean isInterval() { scale!=null && scale==Scale.INTERVAL }
	op boolean isOrdinal() { scale!=null && scale==Scale.ORDINAL }
	op boolean isRational() { scale!=null && scale==Scale.RATIONAL }
	
	op boolean isString() { measure!=null && measure==Primitive.STRING }
	op boolean isInteger() { measure!=null && measure==Primitive.INTEGER }
	op boolean isDecimal() { measure!=null && measure==Primitive.DECIMAL }
	
	op boolean isNominalString() { isNominal() && isString() }
	
	op boolean isIntervalInteger() { isInterval() && isInteger() }
	op boolean isIntervalDecimal() { isInterval() && isDecimal() }
	op boolean isOrdinalInteger() { isOrdinal() && isInteger() }
	op boolean isOrdinalDecimal() { isOrdinal() && isDecimal() }
	op boolean isRationalInteger() { isRational() && isInteger() }
	op boolean isRationalDecimal() { isRational() && isDecimal() }
}
