@Ecore(
	nsPrefix="ontouml-menthor", //Used for XMI serialization
	nsURI="http://menthor.net/" 
)

@GenModel( 
	testsDirectory="/net.menthor.metamodel.ontouml.tests/src-gen",
	editDirectory="/net.menthor.metamodel.ontouml.edit/src-gen",
	editorDirectory="/net.menthor.metamodel.ontouml.editor/src-gen",
	fileExtensions="mouml"
)
 
package net.menthor.metamodel.ontouml

// TODO: JP: Name Spaces like in UML (with package imports)

/* TODO: JP: Create a separate meta-model for "occurrences" of the elements in views
 * (similar to occurrences and definitions in ARIS) keep this meta-model for definitions
 * and create a meta-model for occurrences. This will enable a strict separation between model and views */

@Ecore(validationDelegates="http://www.eclipse.org/emf/2002/Ecore/OCL/Pivot")

/** =========================================
 *  general super-classes
 *  ======================================== */
 
abstract class Element { }

abstract class NamedElement extends Element { String name }

abstract class Container extends NamedElement 
{ 
	contains unordered unique ContainedElement[*] elements opposite holder
}

abstract class ContainedElement extends Element 
{ 
	container Container[1] holder opposite elements
	
	contains Comment[*] comments opposite owner
}

/** =========================================
 *  comment
 *  ======================================== */

class Comment extends Element 
{ 
	String content
	container ContainedElement[1] owner opposite comments
}

/** =========================================
 *  model & package
 *  ======================================== */

class Model extends Container { }

class Package extends Container, ContainedElement { }

/** =========================================
 *  class stereotypes
 *  ======================================== */

enum Universal 
{	
	Kind, Collective, Quantity, Relator, Mode, Quality,  
	Role, Phase, SubKind, Category, Mixin, RoleMixin, 
	PhaseMixin, Event, Hou, DataType, Enumeration
}

enum Quality 
{
	Nominal, Perceivable, NonPerceivable	
}

/** =========================================
 *  class
 *  ======================================== */
 
abstract class Classifier extends ContainedElement {}
 
class Class extends NamedElement, Classifier
{	
	Universal[0..1] stereotype
	
	Quality[0..1] qualityType // Constraint C3
	String[*] enumerationLiterals // Constraint C1
	
	boolean isAbstract	
	boolean isDerived	
	derived boolean isExtensional /* TODO */
	
	contains unordered unique Attribute[*] attributes opposite owner
	
	refers unordered unique Relationship[*] istruthMakerOf opposite truthMaker //only iff isTruthMaker()
	
	refers unordered unique Class[*] instanceOf // Constraint C2
	
	refers unordered unique GeneralizationSet[*] isSpecializedVia opposite specializedClass
	refers unordered unique GeneralizationSet[*] specializesVia opposite specializingClasses	
		
	//==============================================
	//Operations
	//==============================================
	
	op boolean isKind(){stereotype==Universal.KIND}
	op boolean isSubKind(){stereotype==Universal.SUB_KIND}
	op boolean isCollective(){stereotype==Universal.COLLECTIVE}
	op boolean isQuantity(){stereotype==Universal.QUANTITY}
	op boolean isRelator(){stereotype==Universal.RELATOR}
	op boolean isMode(){stereotype==Universal.MODE}
	op boolean isQuality(){stereotype==Universal.QUALITY}
	op boolean isRole(){stereotype==Universal.ROLE}
	op boolean isRoleMixin(){stereotype==Universal.ROLE_MIXIN}
	op boolean isPhaseMixin(){stereotype==Universal.PHASE_MIXIN}
	op boolean isPhase(){stereotype==Universal.PHASE}
	op boolean isCategory(){stereotype==Universal.CATEGORY}
	op boolean isMixin(){stereotype==Universal.MIXIN}
	op boolean isEvent(){stereotype==Universal.EVENT}
	op boolean isHighOrder(){stereotype==Universal.HOU}
	op boolean isDataType(){stereotype==Universal.DATA_TYPE}
	op boolean isEnumeration(){stereotype==Universal.ENUMERATION}
	op boolean isRigid() { isKind() || isCollective() || isQuantity() ||isRelator() || isMode() || isQuality() ||isSubKind() || isCategory() } 
	op boolean isNonRigid() { isRole()|| isPhase() || isRoleMixin() || isMixin() } 
	op boolean isAntiRigid() { isRole() || isPhase() || isRoleMixin() }
	 
	/* Direct children */
	op Class[] children() 
	{		
		var Class[] list
		for(GeneralizationSet gs: isSpecializedVia) { 
			list.addAll(gs.specializingClasses);		
		}
		return list.toEList;
	}

	/** Direct parents */
	op Class[] parents() 
	{
		var Class[] list
		for(GeneralizationSet gs: specializesVia) { 
			list.add(gs.specializedClass);		
		}
		return list.toEList;
	}		
	
	op void identidyProvider(){}	
	op void isFunctionalComplex(){}	
	op void isCollection(){}
	op void isAmountOfMatter(){}
	op void isIntrinsic(){}
	op boolean isTruthMaker(){ isRelator() && istruthMakerOf.size()>0}	
	op void setIsExtensional(){}
}

/** =========================================
 *  generalization set
 *  ======================================== */

class GeneralizationSet extends NamedElement, ContainedElement
{
	boolean isCovering
	
	/* JP: Default should be true, but isDijoint has been removed. Use different GeneralizationSets if necessary to represent disjointness. */
	// boolean isDisjoint 
		
	/* JP: We diverge from UML, which refers to Generalizations from a GeneralizationSet */
	refers Class[1] specializedClass opposite isSpecializedVia
	refers unordered unique Class[1..*] specializingClasses opposite specializesVia
		
	refers Class[0..1] hou 
}

/** =========================================
 *  attribute & end-point
 *  ======================================== */

abstract class Property extends NamedElement 
{		
	boolean isOrdered
	boolean isDerived	
	int[1] lowerBound
	int[1] upperBound	
	boolean isDependee	
}

class EndPoint extends Property
{	
	container Relationship[1] owner opposite endPoints
	
	refers Classifier[1] endType
	
	refers unordered unique EndPoint[*] subsets opposite isSubsettedBy
	refers unordered unique EndPoint[*] redefines opposite isRedefinedBy
	
	refers unordered unique EndPoint[*] isSubsettedBy opposite subsets
	refers unordered unique EndPoint[*] isRedefinedBy opposite redefines
}

class Attribute extends Property
{
	container Class[1] owner opposite attributes
	
	refers PrimitiveType[1] primitiveType  	
}

/** =========================================
 *  primitive stereotypes
 *  ======================================== */
 
enum Primitive
{
	/** JP: This is a direct way to implement built-in types, differently from UML in which 
	 *  this should be a library of built-ins at model level */
	Boolean, String, Real, Integer, UnlimitedNatural
}

/** =========================================
 *  primitive class
 *  ======================================== */

class PrimitiveType extends ContainedElement
{
	Primitive[1] primitive 
}

/** =========================================
 *  relationship stereotypes
 *  ======================================== */
 
enum Relation 
{
	//UFO-A
	ComponentOf
	MemberOf
	SubCollectionOf
	SubQuantityOf
	Constitution
	Characterization
	Mediation
	Material
	Formal
	Structuration
	Derivation
	//UFO-B
	Participation
	SubEventOf
	Causation //Causality, CausedBy
	Temporal	
}

enum AllenRelation
{
	Starts
	Precedes
	Equals
	Meets
	Finishes
	Overlaps
	During
}

/** =========================================
 *  relationship
 *  ======================================== */
 
abstract class Relationship extends Classifier
{	
	/* JP: I assume there is no reason to distinguish ordered and non-ordered, as all should be non-ordered. 
	 * We assume ordered end points... 
	 * http://link.springer.com/chapter/10.1007%2F978-3-642-41924-9_40 */
	 
	/* JP: I assume all are unique as well (mapping to sets and not bags). */
	/* JP: If there are two relators relating the same entities, there should not be two material relations 
	 * between the same entities... the tuples are identical e.g., you should not say that there are two "student at" 
	 * relations between "Student" and "University" even if there are two "Enrollments".  */
	
	Relation[0..1] stereotype
	
	AllenRelation[0..1] allenRelation //only iff isTemporal()
	  
	contains EndPoint[*] endPoints opposite owner	
	
	refers Class[0..1] truthMaker opposite istruthMakerOf //only iff isMaterial()
		  
	//==============================================
	//Operations
	//==============================================
	
	op void isShareable() { /*TODO*/ }
	
	op boolean isComponentOf(){stereotype==Relation.COMPONENT_OF}
	op boolean isMemberOf(){stereotype==Relation.MEMBER_OF}
	op boolean isSubCollectionOf(){stereotype==Relation.SUB_COLLECTION_OF}
	op boolean isSubQuantityOf(){stereotype==Relation.SUB_QUANTITY_OF}
	op boolean isConstitution(){stereotype==Relation.CONSTITUTION}	
	op boolean isCharacterization(){stereotype==Relation.CHARACTERIZATION}
	op boolean isMediation(){stereotype==Relation.MEDIATION}
	op boolean isMaterial(){stereotype==Relation.MATERIAL}
	op boolean isFormal(){stereotype==Relation.FORMAL}
	op boolean isStructuration(){stereotype==Relation.STRUCTURATION}
	op boolean isParticipation(){stereotype==Relation.PARTICIPATION}
	op boolean isSubEventOf(){stereotype==Relation.SUB_EVENT_OF}
	op boolean isCausation(){stereotype==Relation.CAUSATION}
	op boolean isTemporal(){stereotype==Relation.TEMPORAL}	
	
	op boolean isStarts(){allenRelation==AllenRelation.STARTS && isTemporal()}
	op boolean isPrecedes(){allenRelation==AllenRelation.PRECEDES && isTemporal()}
	op boolean isEquals(){allenRelation==AllenRelation.EQUALS && isTemporal()}
	op boolean isMeets(){allenRelation==AllenRelation.MEETS && isTemporal()}
	op boolean isFinishes(){allenRelation==AllenRelation.FINISHES && isTemporal()}
	op boolean isOverlaps(){allenRelation==AllenRelation.OVERLAPS && isTemporal()}
	op boolean isDuring(){allenRelation==AllenRelation.DURING && isTemporal()}		
	op boolean isMeronymic() { isComponentOf() || isMemberOf() || isSubQuantityOf() || isSubCollectionOf() }	
} 
	
/** =========================================
 *  binary relationship
 *  ======================================== */	
	
abstract class BinaryRelationship extends Relationship
{
	op EndPoint sourceEndPoint() { return endPoints.get(0) }	
	op EndPoint targetEndPoint() { return endPoints.get(1) }
	
	op boolean isDerived() { sourceEndPoint().isDerived || targetEndPoint().isDerived }	
}

class BinaryClassRelationship extends NamedElement, BinaryRelationship
{
	op Class sourceClass() 
	{ 
		if(endPoints.get(0).endType instanceof Class) { return endPoints.get(0).endType as Class }
		else { return null; }
	}
		
	op Class targetClass() 
	{ 
		if(endPoints.get(1).endType instanceof Class) { return endPoints.get(1).endType as Class }
		else { return null; }
	}
	
	op boolean isPartEssential() { targetEndPoint().isDependee && sourceClass().isRigid() && isMeronymic() }  
	op boolean isPartInseparable() { sourceEndPoint().isDependee && targetClass().isRigid() && isMeronymic() }
	op boolean isPartImmutable() { sourceEndPoint().isDependee && targetClass().isAntiRigid() && isMeronymic()} 
	op boolean isWholeImmutable() { targetEndPoint().isDependee && sourceClass().isAntiRigid() && isMeronymic()}
	op boolean isPartMandatory() { targetEndPoint().lowerBound>=1 && isMeronymic()}
	op boolean isWholeMandatory() { sourceEndPoint().lowerBound>=1 && isMeronymic()}		 
}	

class DerivationRelationship extends BinaryRelationship
{
	op BinaryClassRelationship sourceRelationship() 
	{ 
		if(endPoints.get(0).endType instanceof BinaryClassRelationship) { return endPoints.get(0).endType as BinaryClassRelationship }
		else { return null; }
	}
	
	op Class targetClass()  
	{ 
		if(endPoints.get(1).endType instanceof Class) { return endPoints.get(1).endType as Class }
		else { return null; }
	}
}

/** =========================================
 *  n-ary relationship
 *  ======================================== */
 
class NAryClassRelationship extends NamedElement, Relationship 
{	
		
}

/** =========================================
 *  quality domain
 *  ======================================== */
 
class MeasurementDomain extends NamedElement, ContainedElement 
{
	refers MeasurementDimension[2..*] dimensions opposite owner 
}

/** =========================================
 *  quality dimension
 *  ======================================== */

class MeasurementDimension extends NamedElement, ContainedElement 
{
	int[1] lowerBound
	int[1] upperBound
	String unitOfMeasure
	
	DimensionType[1] dimension
	MeasurementType[1] measurement
	
	refers MeasurementDomain[0..1] owner opposite dimensions
}

enum DimensionType
{
	Interval, Rational, Ordinal
}

enum MeasurementType
{
	Integer, Decimal
}

class NominalDimension extends NamedElement, ContainedElement { }

/** =========================================
 *  quality region
 *  ======================================== */
 
class MeasurementRegion extends NamedElement, ContainedElement
{
	Region[1] region
}

enum Region
{
	Integer, Decimal, Composed
}

class StringNominalRegion extends NamedElement, ContainedElement {}

/** =========================================
 *  quality enumeration
 *  ======================================== */
 
class MeasurementEnumeration extends NamedElement, ContainedElement
{
	//groundingStructure
	//ownedLiteral
}

