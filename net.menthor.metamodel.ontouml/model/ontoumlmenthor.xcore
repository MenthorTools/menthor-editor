@Ecore(
	nsPrefix="ontouml-menthor", //Used for XMI serialization
	nsURI="http://menthor.net/" 
)

@GenModel( 
	testsDirectory="/net.menthor.metamodel.ontouml.tests/src-gen",
	editDirectory="/net.menthor.metamodel.ontouml.edit/src-gen",
	editorDirectory="/net.menthor.metamodel.ontouml.editor/src-gen",
	fileExtensions="mouml"
)
 
package net.menthor.metamodel.ontouml

/** ======================================================================================================= 
 *  OntoUML 2.0 
 * 
 * 	author: John Guerson [JG]	
 * 	author: Tiago Prince Sales [TS] 	  
 *  co-author: Joao Paulo Andrade Almeida [JP]
 *  ======================================================================================================== */
 
/** ======================================================================================================== 
 *    TODO:
 *  
 *  - (JP) Name Spaces like in UML (with package imports)
 *  - (JP) Create a separate meta-model for "occurrences" of the elements in views (similar to occurrences and definitions in ARIS)
 *         Keep this meta-model for definitions and create a meta-model for occurrences. This will enable a strict separation between model and views
 *  - (TS) Rule to enforce sub-setting and redefinition constraints
 *  - (TS) Implement the following operations: overlapSiblings(), disjointSiblings(), isDisjointOf(Class c)
 *  ======================================================================================================== */  
	 
@Ecore(validationDelegates="http://www.eclipse.org/emf/2002/Ecore/OCL/Pivot")

abstract class Element { }

/** =========================================
 *  Named Element
 *  ======================================== */
 
abstract class NamedElement extends Element { String name }

/** =========================================
 *  Container: is a Named Element that can contain a set of: 
 *             Packages, Generalization Sets, Relationships, Classes and DataTypes  
 *  ======================================== */
 
abstract class Container extends NamedElement 
{ 
	contains unordered unique ContainedElement[*] elements opposite holder
	
	/* Returns the packages at this container. */  
	op Package[] packages()
	{
		var Package[] result
		for(ContainedElement e: elements){
			if(e instanceof Package) { result.add(e); }			
		}
		return result.toEList;
	}
	
	/** Returns recursively all packages at this container. */
	op void allPackages(Container c, Package[] result)
	{		
		for(ContainedElement e: elements){
			if(e instanceof Package) { 
				result.add(e);				
				allPackages(e,result);
			}				
		}		
	}	
	op Package[] allPackages()
	{
		var Package[] result
		allPackages(this, result.toEList)
		return result.toEList;
	} 
	
	/* Returns the relationships at this container */
	op Relationship[] relationships() 
	{	
		var Relationship[] result
		for(ContainedElement e: elements){
			if(e instanceof Relationship) { result.add(e) }
		}
		return result.toEList;
	}
	
	/** Returns recursively all relationships at this container */
	op void allRelationships(Container c, Relationship[] result)
	{		
		for(ContainedElement e: elements){
			if(e instanceof Relationship) { result.add(e); }
			if(e instanceof Package){
				allRelationships(e,result);								
			}
		}
	}	
	op Relationship[] allRelationships()
	{
		var Relationship[] result
		allRelationships(this, result.toEList)
		return result.toEList;
	} 
	
	/* Returns the generalization sets at this container */
	op GeneralizationSet[] generalizationSets()
	{
		var GeneralizationSet[] result
		for(ContainedElement e: elements){
			if(e instanceof GeneralizationSet) { result.add(e) }
		}
		return result.toEList;		
	} 
	 
	/** Returns recursively all generalization sets at this container */
	op void allGeneralizationSets(Container c, GeneralizationSet[] result)
	{		
		for(ContainedElement e: elements){
			if(e instanceof GeneralizationSet) { result.add(e); }
			if(e instanceof Package){
				allGeneralizationSets(e,result);								
			}
		}
	}	
	op GeneralizationSet[] allGeneralizationSets()
	{
		var GeneralizationSet[] result
		allGeneralizationSets(this, result.toEList)
		return result.toEList;
	} 
	
	/* Returns the classes at this container */
	op Class[] classes()
	{
		var Class[] result
		for(ContainedElement e: elements){
			if(e instanceof Class) { result.add(e) }
		}
		return result.toEList;		
	}
	
	/** Returns recursively all classes at this container */
	op void allClasses(Container c, Class[] result)
	{		
		for(ContainedElement e: elements){
			if(e instanceof Class) { result.add(e); }
			if(e instanceof Package){
				allClasses(e,result);								
			}
		}
	}	
	op Class[] allClasses()
	{
		var Class[] result
		allClasses(this, result.toEList)
		return result.toEList;
	}
	
	/* Returns the dataTypes at this container */
	op DataType[] dataTypes()
	{
		var DataType[] result
		for(ContainedElement e: elements){
			if(e instanceof DataType) { result.add(e) }
		}
		return result.toEList;		
	}
	
	/** Returns recursively all dataTypes at this container */
	op void allDataTypes(Container c, DataType[] result)
	{		
		for(ContainedElement e: elements){
			if(e instanceof DataType) { result.add(e); }
			if(e instanceof Package){
				allDataTypes(e, result);								
			}
		}
	}	 
	op DataType[] allDataTypes()
	{
		var DataType[] result
		allDataTypes(this, result.toEList)
		return result.toEList;
	}	

	/* Returns the types (classes and dataTypes) at this container */
	op Type[] types()
	{
		var Type[] result
		for(ContainedElement e: elements){
			if(e instanceof Type) { result.add(e) }
		}
		return result.toEList;		
	}
	
	/** Returns recursively all types (classes and dataTypes) at this container */
	op void allTypes(Container c, Type[] result)
	{		
		for(ContainedElement e: elements){
			if(e instanceof Type) { result.add(e); }
			if(e instanceof Package){
				allTypes(e, result);								
			}
		}
	}	 
	op Type[] allTypes()
	{
		var Type[] result
		allTypes(this, result.toEList)
		return result.toEList;
	}	
}

/** =========================================
 *  Contained Element: is an Element that has a a container and possibly a set of comments.                    
 *  ========================================= */    
 
abstract class ContainedElement extends Element 
{ 
	container Container[1] holder opposite elements	
	contains Comment[*] comments opposite owner	
	
	/** Returns the root from a given container */
	op Model getModel(Container c)
	{
		if(c instanceof Model) { return c; }
		else { if(c instanceof ContainedElement) return getModel(c.holder); }
	}
	/** Returns the root container */
	op Model getModel()
	{
		return getModel(holder);
	}
}

/** =========================================
 *  Comment: is a text which has an owner
 *  ======================================== */

class Comment extends Element 
{ 
	String content
	container ContainedElement[1] owner opposite comments
}

/** =========================================
 *  Model: is just a Container
 *  ======================================== */

class Model extends Container { }

/** =========================================
 *  Package: is both a Container and a ContainedElement
 *  ======================================== */

class Package extends Container, ContainedElement { }

/** =========================================
 *  Classifier: is a type (class or dataType) or a relationship. 
 *  ======================================== */
 
abstract class Classifier extends ContainedElement 
{
	String[*] definitions
	String[*] synonyms
	String[?] text
	
	refers unordered unique GeneralizationSet[*] isSpecializedVia opposite specializedClassifier
	refers unordered unique GeneralizationSet[*] specializesVia opposite specializingClassifier
	
	/* Direct children */
	op Classifier[] children() 
	{		
		var Class[] list
		for(GeneralizationSet gs: isSpecializedVia) { 
			list.addAll(gs.specializingClassifier);		
		}
		return list.toEList;
	}

	/** Direct parents */
	op Classifier[] parents() 
	{
		var Classifier[] list
		for(GeneralizationSet gs: specializesVia) { 
			list.add(gs.specializedClassifier);		
		}
		return list.toEList;
	}
	
	/** All (direct and indirect) parents */
	op void allParents(Classifier c, Classifier[] result) 
	{		
		for(GeneralizationSet gs: specializesVia) { 
			result.add(gs.specializedClassifier);
			allParents(gs.specializedClassifier,result);					
		}		
	}	
	/** All (direct and indirect) parents */
	op Classifier[] allParents()
	{
		var Classifier[] list
		allParents(this, list.toEList)
		return list.toEList;
	}
	
	/* All (direct and indirect) children */
	op void allChildren(Classifier c, Classifier[] result) 
	{		
		for(GeneralizationSet gs: isSpecializedVia) { 
			result.addAll(gs.specializingClassifier);
			for(Classifier children: gs.specializingClassifier) {				
				allChildren(children, result);			
			}					
		}		
	} 
	/* All (direct and indirect) children */
	op Classifier[] allChildren()
	{
		var Classifier[] list
		allChildren(this, list.toEList)
		return list.toEList;
	}
	
	/** Returns direct siblings i.e. classifiers which specialize the same super-classifier as this classifier */
	op Classifier[] siblings() 
	{
		var Classifier[] result
		for(Classifier p: parents()){			
			for(Classifier sibling: p.children()){				
				if(!sibling.equals(this)) result.add(sibling);				
			}
		}
		return result.toEList;			
	}	
	
	/** Returns all direct end-points from this classifier (in which we can navigate from it) 
	 *  In other words, it returns all opposite ends of the relationships connected to this classifier. */		
	op EndPoint[] ends()
	{		
		var EndPoint[] result
		for(Relationship rel: model.allRelationships){
			if(rel.isEnd(this)){
				for(EndPoint ep: rel.endPoints){
					if(!ep.endType.equals(this)){
						result.add(ep);
					}	
				}
			}			
		}	
		return result.toEList;	
	}
		  
	/** Returns all direct and indirect end-points from this classifier (in which we can navigate from it) 
	 *  In other words, it returns all opposite ends of the relationships connected to this classifier, or to a parent of this classifier. */
	op EndPoint[] allEnds() 
	{		
		var EndPoint[] result
		result.addAll(this.ends());
		for(Classifier p: this.allParents()){
			if(p instanceof Class){
				result.addAll(p.ends());
			}
		}
		return result.toEList;		
	}	
}

/** =========================================
 *  Type: is a class or a dataType  
 *  ========================================= */
 
abstract class Type extends Classifier {
		
	contains unordered unique Attribute[*] attributes opposite owner
	
	/** Returns all types directly connected to this type through a relationship. */
	op Type[] relatedTypes(){
		var Type[] result
		for(EndPoint ep: ends()){
			result.add(ep.endType as Type)			
		}
		return result.toEList;
	}
	
	/**Returns all types directly and indirectly connected to this type through a relationship. */
	op Type[] allRelatedTypes(){
		var Type[] result
		for(EndPoint ep: allEnds()){
			result.add(ep.endType as Type)			
		}
		return result.toEList;
	}
}

/** =========================================
 *  Property: is an attribute or an end-point
 *  ======================================== */

abstract class Property extends NamedElement 
{		
	boolean isOrdered
	boolean isDerived	
	int[1] lowerBound
	int[1] upperBound	
	boolean isDependency	
}

/** =========================================
 *  PrimitiveType Stereotype
 *  ======================================== */
 
enum PrimitiveStereotype
{
	Boolean, String, Real, Integer, Date, DateTime
}

/** =========================================
 *  Attribute: has a primitive type and an owner (a class or a dataType)
 *  ======================================== */
class Attribute extends Property
{
	String[*] definitions	
	String[*] synonyms
	String[?] text
	
	PrimitiveStereotype[?] stereotype
	
	container Type[1] owner opposite attributes
}

/** =========================================
 *  Generalization Set: is a specialization/generalization between two Classifiers.   
 *                      A former UML generalization is now a Generalization Set with 
 *                      only one specializing classifier.
 *  ======================================== */

class GeneralizationSet extends NamedElement, ContainedElement
{
	boolean isCovering		
	refers Classifier[1] specializedClassifier opposite isSpecializedVia 
	refers unordered unique Classifier[1..*] specializingClassifier opposite specializesVia		
	refers Class[?] highOrder
}

/** =========================================
 *  Class Stereotype
 *  ======================================== */

enum ClassStereotype 
{	
	Kind, Collective, Quantity, 
	Relator, Mode, Quality,  
	Role, Phase, SubKind, 
	Category, Mixin, RoleMixin, PhaseMixin,		
	Event, 	
	HighOrder 
}

/** =========================================
 *  DataType Stereotype
 *  ======================================== */
 
enum DataTypeStereotype
{
	Domain, Dimension, Enumeration, DataType
}

/** =========================================
 *  Enumeration Literal
 *  ======================================== */

class Literal extends Element
{
	String value
	container DataType[1] owner opposite literals		
	float upperBoundRegion
	float lowerBoundRegion
}

/** =========================================
 *  Structure Scale and Basic Type
 *  ======================================== */
 
enum Scale
{
	Interval, Rational, Ordinal, Nominal
}

enum Measurement
{
	Integer, Real, Decimal, String
}

/** =========================================
 *  DataType: is a Domain, Dimension, Enumeration or DataType
 *  ======================================== */
 
class DataType extends Type, NamedElement
{
	DataTypeStereotype stereotype	
	
	//Domain
	refers DataType[*] dimensions opposite ownerDomain
	
	//Dimension
	Scale[?] scale 
	Measurement[?] measurement
	String unitOfMeasure
	float lowerBoundRegion 
	float upperBoundRegion
	refers DataType[?] ownerDomain opposite dimensions	
	
	//Enumeration
	contains Literal[*] literals opposite owner			
	refers DataType[?] structure
	
	op boolean isEnumeration(){stereotype==DataTypeStereotype.ENUMERATION}
	op boolean isDomain(){stereotype==DataTypeStereotype.DOMAIN}
	op boolean isDimension(){stereotype==DataTypeStereotype.DIMENSION}
	op boolean isDataType(){stereotype==DataTypeStereotype.DATA_TYPE}	
	
	op boolean isNominal() { scale!=null && scale==Scale.NOMINAL }
	op boolean isInterval() { scale!=null && scale==Scale.INTERVAL }
	op boolean isOrdinal() { scale!=null && scale==Scale.ORDINAL }
	op boolean isRational() { scale!=null && scale==Scale.RATIONAL }	
	
	op boolean isString() { measurement!=null && measurement==Measurement.STRING }
	op boolean isInteger() { measurement!=null && measurement==Measurement.INTEGER }
	op boolean isDecimal() { measurement!=null && measurement==Measurement.DECIMAL }	
	op boolean isReal() { measurement!=null && measurement==Measurement.REAL }
	
	op boolean isNominalString() { isNominal() && isString() }	
	op boolean isIntervalInteger() { isInterval() && isInteger() }
	op boolean isIntervalDecimal() { isInterval() && isDecimal() }
	op boolean isOrdinalInteger() { isOrdinal() && isInteger() }
	op boolean isOrdinalDecimal() { isOrdinal() && isDecimal() }
	op boolean isRationalInteger() { isRational() && isInteger() }
	op boolean isRationalDecimal() { isRational() && isDecimal() }
	op boolean isIntervalReal() { isInterval() && isReal() }
	op boolean isOrdinalReal() { isOrdinal() && isReal() }
	op boolean isRationalReal() { isRational() && isReal() }
}

/** =========================================
 *  Quality Nature
 *  ======================================== */
 
enum QualityNature 
{
	Nominal, Perceivable, NonPerceivable	
}

/** =========================================
 *  Classification
 *  ======================================== */
 
enum Classification
{
	Initial, Final	
}

/** =========================================
 *  Existence
 *  ======================================== */
 
enum Existence
{
	Permanent, Transient, Eternal	
}

/** =========================================
 *  Class: is an Endurant, Perdurant or a HighOrder class.
 *  ======================================== */

class Class extends Type, NamedElement
{
	ClassStereotype[?] stereotype	
	boolean isAbstract	
	boolean isDerived
	
	//Collective
	boolean isExtensional
	
	//Quality			
	QualityNature[?] qualityNature
	
	//Substance Sortal and Moment	
	Existence[?] existence
	
	//Anti-Rigid
	Classification[?] classification
		
	op boolean isKind(){stereotype==ClassStereotype.KIND}
	op boolean isSubKind(){stereotype==ClassStereotype.SUB_KIND}
	op boolean isCollective(){stereotype==ClassStereotype.COLLECTIVE}
	op boolean isQuantity(){stereotype==ClassStereotype.QUANTITY}
	op boolean isRelator(){stereotype==ClassStereotype.RELATOR}
	op boolean isMode(){stereotype==ClassStereotype.MODE}
	op boolean isQuality(){stereotype==ClassStereotype.QUALITY}
	op boolean isRole(){stereotype==ClassStereotype.ROLE}
	op boolean isRoleMixin(){stereotype==ClassStereotype.ROLE_MIXIN}
	op boolean isPhaseMixin(){stereotype==ClassStereotype.PHASE_MIXIN}
	op boolean isPhase(){stereotype==ClassStereotype.PHASE}
	op boolean isCategory(){stereotype==ClassStereotype.CATEGORY}
	op boolean isMixin(){stereotype==ClassStereotype.MIXIN}
	op boolean isEvent(){stereotype==ClassStereotype.EVENT}
	op boolean isHighOrder(){stereotype==ClassStereotype.HIGH_ORDER}
	
	op boolean isRigid() { isKind() || isCollective() || isQuantity() ||isRelator() || isMode() || isQuality() ||isSubKind() || isCategory() } 
	op boolean isNonRigid() { isRole()|| isPhase() || isRoleMixin() || isPhaseMixin() || isMixin() } 
	op boolean isAntiRigid() { isRole() || isPhase() || isRoleMixin() || isPhaseMixin() }
	op boolean isSemiRigid() { isMixin() }
			
	op boolean isSubstanceSortalClass() { isKind() || isCollective() || isQuantity() }
	op boolean isMomentClass() { isRelator() || isMode() || isQuality() }	
	op boolean isIdentityProviderClass() { isKind() || isQuantity() || isCollective() || isRelator() || isMode() || isQuality() }
	op boolean isMixinClass() { isMixin() || isRoleMixin() || isPhaseMixin() || isCategory() }
	op boolean isAntiRigidMixinClass() { isRoleMixin() || isPhaseMixin() }
			
	/** 
	 * Checks if this element is an amount of matter i.e.
	 * 1) if it is a quantity element, or, 
	 * 2) if it is a subKind or role/phase with exactly one identity provider of the type Quantity, or,
	 * 3) if it is a mixin class in which all their children are quantities.
	 */
	op boolean isAmountOfMatter()
	{
		if(isQuantity()) return true;		
		if(isRole() || isPhase() || isSubKind()) 
		{ 
			var Class[] providers
			providers.addAll(identityProviders());			
			for(Class c: providers) if (c.isQuantity()) return true;
		}		
		if(isMixinClass())
		{
			if(children().size()==0) return false;			
			for (Classifier child : children()) 
			{
				if(child instanceof Class) if(!child.isQuantity()) return false;
			}
			return true;
		}		
		return false;
	}
	
	/** 
	 * Checks if this element is a functional complex i.e.
	 * 1) If it is a kind, or 
	 * 2) if it is a subKind or role/phase with exactly one identity provider of the type kind, or,
	 * 3) if it is a mixin class in which all their children are functional complexes.  
	 */
	op boolean isFunctionalComplex()
	{
		if(isKind()) return true;		
		if(isRole() || isPhase() || isSubKind()) 
		{ 
			var Class[] providers
			providers.addAll(identityProviders());			
			for(Class c: providers) if (c.isKind()) return true;
		}		
		if(isMixinClass())
		{			
			if(children().size()==0) return false;			
			for (Classifier child : children()) 
			{
				if(child instanceof Class) if(!child.isKind()) return false;
			}
			return true;
		}		
		return false;
	}	
	
	/** 
	 * Checks if this element is a collective i.e.
	 * 1) if it is a collective element, or, 
	 * 2) if it is a subKind or role/phase with exactly one identity provider of the type Collective, or,
	 * 3) if it is a mixin class in which all their children are collectives.
	 */
	op boolean isCollection()
	{ 
		if(isCollective()) return true;		
		if(isRole() || isPhase() || isSubKind()) 
		{ 
			var Class[] providers
			providers.addAll(identityProviders());			
			for(Class c: providers) if (c.isCollective()) return true;
		}			
		if(isMixinClass())
		{			
			if(children().size()==0) return false;			
			for (Classifier child : children()) 
			{
				if(child instanceof Class) if(!child.isCollective()) return false;
			}
			return true;
		}		
		return false;
	}	 
	
	/** 
	 * Checks if this element is a moment  i.e.
	 * 1) if it is a moment, mode or quality element, or, 
	 * 2) if it is a subKind or role/phase with exactly one identity provider being a relator, mode or quality, or,
	 * 3) if it is a mixin class in which all their children are relators, qualities or modes.
	 */
	op boolean isMoment()
	{
		if(isMoment()) return true;		
		if(isRole() || isPhase() || isSubKind()) 
		{ 
			var Class[] providers
			providers.addAll(identityProviders());			
			for(Class c: providers) if (c.isMoment()) return true;
		}			
		if(isMixinClass())
		{			
			if(children().size()==0) return false;			
			for (Classifier child : children()) 
			{
				if(child instanceof Class) if(!child.isMoment()) return false;
			}
			return true;
		}		
		return false;
	}
	
	/** 
	 * Checks if this element is a truth maker (relator) i.e.
	 * 1) if it is a truth maker element, or, 
	 * 2) if it is a subKind or role/phase with exactly one identity provider being a truth maker, or,
	 * 3) if it is a mixin class in which all their children are truth makers.
	 */
	op boolean isTruthMaker()
	{
		if(isRelator()) return true;		
		if(isRole() || isPhase() || isSubKind()) 
		{ 
			var Class[] providers
			providers.addAll(identityProviders());			
			for(Class c: providers) if (c.isRelator()) return true;
		}			
		if(isMixinClass())
		{			
			if(children().size()==0) return false;			
			for (Classifier child : children()) 
			{
				if(child instanceof Class) if(!child.isRelator()) return false;
			}
			return true;
		}		
		return false;		
	}	
	
	/** Returns the identity providers amongst all parents of a class (more than one may be found) */
	op Class[] identityProvidersAtAllParents()
	{
		var Class[] result
		for(Classifier p: allParents()) {
			if(p instanceof Class){		
				if(p.isIdentityProviderClass()) result.add(p);
			}			
		}
		return result.toEList;
	}

	/** Returns the identity providers amongst all children of a class (more than one may be found) */
	op Class[] identityProvidersAtAllChildren()
	{
		var Class[] result
		for(Classifier p: allChildren()) {
			if(p instanceof Class){		
				if(p.isIdentityProviderClass()) result.add(p);
				if(p.isRole() || isPhase() || p.isSubKind()) result.addAll(p.identityProvidersAtAllParents());
			}			
		}
		return result.toEList;
	}	
	
	/** Returns the identity providers of a class (more than one may be found) */
	op Class[] identityProviders()
	{
		var Class[] result
		if (isIdentityProviderClass()) {
			result.add(this);
		}				
		if (isRole() || isPhase() || isSubKind()) { 
			result.addAll(identityProvidersAtAllParents());
		}	
		if (isMixinClass())
		{
			result.addAll(identityProvidersAtAllChildren());	
			for(Classifier p: allParents()) {
				if(p instanceof Class){		
					result.addAll(p.identityProvidersAtAllChildren());
				}
			}	
		}
		return result.toEList;			
	}	
}

/** =========================================
 *  End-Point
 *  ======================================== */
 
class EndPoint extends Property
{
	container Relationship[1] owner opposite endPoints	
	refers Classifier[1] endType
	refers unordered unique EndPoint[*] subsets opposite isSubsettedBy
	refers unordered unique EndPoint[*] redefines opposite isRedefinedBy	
	refers unordered unique EndPoint[*] isSubsettedBy opposite subsets
	refers unordered unique EndPoint[*] isRedefinedBy opposite redefines
}

/** =========================================
 *  Relationship Stereotype
 *  ======================================== */
 
enum RelationshipStereotype 
{
	ComponentOf
	MemberOf
	SubCollectionOf
	SubQuantityOf
	Constitution
	Characterization
	Mediation
	Material
	Formal
	Derivation
	Structuration		
	Participation
	SubEventOf
	Causation
	Temporal
	InstanceOf	
}

/** =========================================
 *  Temporal Nature
 *  ======================================== */
 
enum TemporalNature
{
	Starts
	Precedes
	Equals
	Meets
	Finishes
	Overlaps
	During
}

/** =========================================
 *  Participation Nature
 *  ======================================== */
 
enum ParticipationNature
{
	Creation
	Change
	Destruction		
}

/** =========================================
 *  Binary Features
 *  ======================================== */
  
 enum Reflexivity 
 {
 	Reflexive
 	Irreflexive
 	NonReflexive
 }
 
 enum Symmetry
 {
 	Symmetric
 	Assymetric
 	AntiSymmetric
 	NonSymmetric
 }
 
 enum Transitivity
 {
 	Transitive
 	Intransitive
 	NonTransitive
 }
 
 enum Ciclicity
 {
 	Cyclic
 	Acyclic
 	NonCyclic	
 }
 
/** =========================================
 *  Relationship 
 *  ======================================== */
 
class Relationship extends Classifier, NamedElement
{		
	RelationshipStereotype[?] stereotype	
	Reflexivity[?] reflexivity
	Symmetry[?] symmetry
	Transitivity[?] transitivity
	Ciclicity[?] ciclicity
	contains EndPoint[*] endPoints opposite owner
	
	//Temporal
	TemporalNature[?] temporalNature
	
	//Participation	  
	ParticipationNature[?] participationNature
		
	op boolean isComponentOf(){stereotype==RelationshipStereotype.COMPONENT_OF}
	op boolean isMemberOf(){stereotype==RelationshipStereotype.MEMBER_OF}
	op boolean isSubCollectionOf(){stereotype==RelationshipStereotype.SUB_COLLECTION_OF}
	op boolean isSubQuantityOf(){stereotype==RelationshipStereotype.SUB_QUANTITY_OF}
	op boolean isConstitution(){stereotype==RelationshipStereotype.CONSTITUTION}	
	op boolean isCharacterization(){stereotype==RelationshipStereotype.CHARACTERIZATION}
	op boolean isMediation(){stereotype==RelationshipStereotype.MEDIATION}
	op boolean isMaterial(){stereotype==RelationshipStereotype.MATERIAL}
	op boolean isFormal(){stereotype==RelationshipStereotype.FORMAL}
	op boolean isStructuration(){stereotype==RelationshipStereotype.STRUCTURATION}
	op boolean isParticipation(){stereotype==RelationshipStereotype.PARTICIPATION}
	op boolean isSubEventOf(){stereotype==RelationshipStereotype.SUB_EVENT_OF}
	op boolean isCausation(){stereotype==RelationshipStereotype.CAUSATION}
	op boolean isTemporal(){stereotype==RelationshipStereotype.TEMPORAL}
	op boolean isInstanceOf(){stereotype==RelationshipStereotype.INSTANCE_OF}	
	op boolean isMeronymic() { isComponentOf() || isMemberOf() || isSubQuantityOf() || isSubCollectionOf() || isConstitution() || isSubEventOf() }	
	op boolean isBinary() { return endPoints.size()==2 }
	op boolean isTernary() { return endPoints.size()==3 }
		
	op boolean isStarts(){isTemporal() && temporalNature==TemporalNature.STARTS }
	op boolean isPrecedes(){isTemporal() && temporalNature==TemporalNature.PRECEDES}
	op boolean isEquals(){isTemporal() && temporalNature==TemporalNature.EQUALS}
	op boolean isMeets(){isTemporal() && temporalNature==TemporalNature.MEETS}
	op boolean isFinishes(){isTemporal() && temporalNature==TemporalNature.FINISHES}
	op boolean isOverlaps(){isTemporal() && temporalNature==TemporalNature.OVERLAPS}
	op boolean isDuring(){isTemporal() && temporalNature==TemporalNature.DURING}
	
	op boolean isCreation() { return isParticipation() && participationNature == ParticipationNature.CREATION }
	op boolean isDestruction() { return isParticipation() && participationNature == ParticipationNature.DESTRUCTION }
	op boolean isChange() { return isParticipation() && participationNature == ParticipationNature.CHANGE }
		
	/** Returns the source (first end-point) of this relationship */
	op EndPoint sourceEnd() 
	{ 
		if(endPoints.size()>0){ return endPoints.get(0) } 
		return null;
	} 
	
	/** Returns the target (second end-point) of this relationship */
	op EndPoint targetEnd() 
	{ 
		if(endPoints.size()>1){ return endPoints.get(1) } 
		return null;
	}
	
	/** Returns the source (first end-classifier) of this relationship */
	op Classifier source() 
	{ 
		if(sourceEnd()!=null){ return sourceEnd().endType } 
		return null;
	}
	
	/** Returns the target (second end-classifier) of this relationship */
	op Classifier target()  
	{ 
		if(targetEnd()!=null){ return targetEnd().endType }		
		return null;
	}
		
	/** Returns the source (first end-class) of this relationship */
	op Class sourceClass() 
	{ 
		if(source()!=null) return source() as Class		
		return null; 
	}
	
	/** Returns the target (second end-class) of this relationship */
	op Class targetClass()  
	{ 
		if(target()!=null) return target() as Class		
		return null;  
	}	
	
	/** Returns the source (first end-dataType) of this relationship */
	op DataType sourceDataType() 
	{ 
		if(source()!=null) return source() as DataType		
		return null; 
	}
	
	/** Returns the target (second end-dataType) of this relationship */
	op DataType targetDataType()  
	{ 
		if(target()!=null) return target() as DataType		
		return null;  
	}
	
	/** Returns the source (first end-relationship) of this relationship */
	op Relationship sourceRelationship() 
	{ 
		if(source()!=null) return source() as Relationship		
		return null; 
	}
		
	/** Returns the target (second end-relationship) of this relationship */
	op Relationship targetRelationship()  
	{ 
		if(target()!=null) return target() as Relationship		
		return null;  
	}	
	
	/** Checks if this relationship is derived i.e. checking if there is at least one end-point which is derived */
	op boolean isDerived() 
	{ 
		for(EndPoint ep: endPoints){ if (ep.isDerived) return true; }
		return false;
	}	
	
	/** Checks if there is at least one end-point in this relationship of classifier c. */	
	op boolean isEnd(Classifier c)
	{
		for(EndPoint ep: endPoints){
			if(ep.endType.equals(c)) return true;
		}
		return false;		
	}	

	/** A part is essential if the target end of a meronymic relationship is dependent on the rigid source type */
	op boolean isPartEssential() { targetEnd().isDependency && sourceClass().isRigid() && isMeronymic() }  
	
	/** A part is inseparable if the source end of a meronymic relationship is dependent on the rigid target type */
	op boolean isPartInseparable() { sourceEnd().isDependency && targetClass().isRigid() && isMeronymic() }
	
	/** A part is immutable if the source end of a meronymic relationship is dependent on the anti-rigid target type */
	op boolean isPartImmutable() { sourceEnd().isDependency && targetClass().isAntiRigid() && isMeronymic()} 
	
	/** A whole is immutable if the target end of a meronymic relationship is dependent on the anti-rigid source type */
	op boolean isWholeImmutable() { targetEnd().isDependency && sourceClass().isAntiRigid() && isMeronymic()}
	
	/** A part is mandatory if the target end of a meronymic relationship has a lower bound of at least 1 */	
	op boolean isPartMandatory() { targetEnd().lowerBound>=1 && isMeronymic()}
	
	/** A whole is mandatory if the source end of a meronymic relationship has a lower bound of at least 1 */
	op boolean isWholeMandatory() { sourceEnd().lowerBound>=1 && isMeronymic()}
	
	/** A part is shareable if the source end of a meronymic relationship has a upper bound greater than 1 */
	op boolean isPartShareable() { sourceEnd().upperBound > 1 && isMeronymic() }	
}
  
